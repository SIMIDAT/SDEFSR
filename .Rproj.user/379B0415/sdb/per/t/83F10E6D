{
    "contents" : "##############################################################################\n#                                                                            #\n#                        GENETIC ALGORITHMS in R                             #\n#                                                                            #      \n#       This functions are the genectic algorithms used by the EFS           #\n#             algorithms that are available in the package.                  #\n#                                                                            #\n##############################################################################\n\n#\n# \n# Genetic algorithm for SDIGA\n#\n#\n\n.gaSDIGA <- function(type = c(\"binary\", \"real-valued\", \"permutation\"), \n               fitness, ...,\n               min, max, nBits,\n               population ,\n               selection,\n               crossover, \n               mutation,\n               popSize = 50, \n               pcrossover = 0.8, \n               pmutation = 0.1, \n               elitism = base::max(1, round(popSize*0.05)), \n               maxiter = 100,\n               run = maxiter,\n               maxfitness = Inf,\n               names = NULL,\n               suggestions = NULL, \n               keepBest = FALSE,\n               parallel = FALSE,\n               monitor = NULL,\n               DNFRules = FALSE,\n               seed = NULL) \n{\n  \n  call <- match.call()\n  \n  type <- match.arg(type)\n\n  \n  if(missing(fitness))\n  { stop(\"A fitness function must be provided\") }\n  if(!is.function(fitness)) \n  { stop(\"A fitness function must be provided\") }\n  if(popSize < 10) \n  { warning(\"The population size is less than 10.\") }\n  if(maxiter < 1) \n  { stop(\"The maximum number of iterations must be at least 1.\") }\n  if(elitism > popSize) \n  { stop(\"The elitism cannot be larger that population size.\") }\n  if(pcrossover < 0 | pcrossover > 1)\n  { stop(\"Probability of crossover must be between 0 and 1.\") }\n  if(is.numeric(pmutation))\n  { if(pmutation < 0 | pmutation > 1)\n  { stop(\"If numeric probability of mutation must be between 0 and 1.\") }\n  else if(!is.function(population))\n  { stop(\"pmutation must be a numeric value in (0,1) or a function.\") }\n  }\n  if(missing(min) & missing(max) & missing(nBits))\n  { stop(\"A min and max range of values (for 'real-valued' or 'permutation' GA) or nBits (for 'binary' GA) must be provided!\") }\n  \n  switch(type, \n         \"binary\"      = { nBits <- as.vector(nBits)[1]\n                           #min <- max <- NA\n                           nvars <- nBits \n         },\n         \"real-valued\" = { min <- as.vector(min)\n                           max <- as.vector(max)\n                           nBits <- NA\n                           if(length(min) != length(max))\n                           { stop(\"min and max must be vector of the same length!\") }\n                           nvars <- length(max) \n         },\n         \"permutation\" = { min <- as.vector(min)[1]\n                           max <- as.vector(max)[1]\n                           nBits <- NA\n                           nvars <- length(seq(min,max)) \n         }\n  )\n  \n \n  \n\n  Fitness <- rep(NA, popSize + 2)\n  \n  \n  \n  object <- new(\".ga\", \n                call = call, \n                type = type,\n                min = min, \n                max = max, \n                nBits = nBits, \n                names = if(is.null(names)) character() else names,\n                popSize = popSize,\n                iter = 0, \n                run = 1, \n                maxiter = maxiter,\n                suggestions = matrix(),\n                population = matrix(), \n                elitism = elitism, \n                pcrossover = pcrossover, \n                pmutation = if(is.numeric(pmutation)) pmutation else NA,\n                fitness = Fitness, \n                summary = matrix(),\n                bestSol = list()\n                )\n  n_evals <- 0\n  if(!is.null(seed)) set.seed(seed)\n  \n  if(!DNFRules)\n    nGenes <- nvars * popSize\n  else\n    nGenes <- (length(max) - 1) * popSize\n  \n  numMutaciones <- ceiling(pmutation * nGenes)\n  \n  object@DNFRules <- DNFRules\n  object@maxValuesRule <- max \n  object@popNew <- matrix(as.double(NA), nrow = popSize, ncol = nvars)\n  \n  # generate beginning population\n \n  Pop <- matrix(as.double(NA), nrow = popSize + 2, ncol = nvars)\n  \n \n  \n   if( ! DNFRules) \n    Pop[1:popSize,] <- population(object)[1:popSize,]\n    else \n    Pop[1:popSize,] <- population(object)[1:popSize,]\n  \n  object@population <- Pop\n  \n  # start iterations\n  for(iter in seq_len(maxiter))\n  {\n    # evalute fitness function (when needed) \n   for(i in seq_len(popSize + 2))\n      if(is.na(Fitness[i]))\n      { Fitness[i] <- fitness(Pop[i,], ...) \n        n_evals <- n_evals + 1} \n   \n\n\n\n# update object\nobject@iter <- iter\nobject@population <- Pop\nobject@fitness <- Fitness\n\n\n\nord <- order(Fitness, decreasing = TRUE)\nPopSorted <- Pop[ord,,drop=FALSE]\nFitnessSorted <- Fitness[ord]\n\n#Keep the population sorted by fitness\nobject@population <- PopSorted\nobject@fitness <- FitnessSorted\n\n\n# check stopping criteria\n\nif(n_evals >= run) break  \nif(max(Fitness, na.rm = TRUE) >= maxfitness) break\nif(object@iter == maxiter) break  \n\n\n# selection\nsel <- selection(object)\nPopSorted <- sel$population\nFitnessSorted <- sel$fitness\n\n  \nobject@population <- PopSorted\nobject@fitness <- FitnessSorted\n\n\n# crossover Only cross the 2 best individuals\n\nparents <- c(1,2)\nCrossover <- crossover(object, parents) # Only the best individuals are crossed\nPopSorted[popSize + parents,] <- Crossover$children\nFitnessSorted[popSize + parents] <- Crossover$fitness\n\n# mutation (only .mutate popLength * probMut chromosomes)\npm <- if(is.function(pmutation)) pmutation(object) else pmutation\nif(DNFRules) nvars <- length(max) - 1\nif(is.function(mutation) & pm > 0)\n{ \n  genes <- sample(x = seq_len(nGenes), size = numMutaciones, replace = TRUE)\n  cromosomas <- floor(genes / nvars) + 1\n  vars <- (cromosomas %% nvars) + 1\n  if(!DNFRules)\n    Mutation <- matrix(data = NA, nrow = numMutaciones, ncol = nvars)\n  else\n    Mutation <- matrix(data = NA, nrow = numMutaciones, ncol = nBits)\n  FitnessSorted[cromosomas] <- NA\n  for(i in seq_len(length(vars))) \n  {     \n    Mutation[i,] <- mutation(object, cromosomas[i], vars[i])\n  }\n  PopSorted[cromosomas,] <- Mutation \n  \n  object@population <- PopSorted\n  object@fitness <- FitnessSorted\n}\n\nPop <- PopSorted\nFitness <- FitnessSorted\n\n}\n\n\n# get solution(s)\nobject@fitnessValue <- max(object@fitness, na.rm = TRUE)\n\n# return an object of class 'ga'\nreturn(object)\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#\n#\n# Genetic algorithm for MESDIF\n#\n#\n\n.gaMESDIF <- function(type = c(\"binary\", \"real-valued\", \"permutation\"), \n               fitness, ...,\n               min, max, nBits,\n               population ,\n               selection ,\n               crossover , \n               mutation ,\n               popSize = 50, \n               pcrossover = 0.8, \n               pmutation = 0.1, \n               elitism = base::max(1, round(popSize*0.05)), \n               maxiter = 100,\n               run = maxiter,\n               maxfitness = Inf,\n               names = NULL,\n               suggestions = NULL, \n               keepBest = FALSE,\n               parallel = FALSE,\n               monitor = NULL,\n               DNFRules = FALSE,\n               seed = NULL) \n{\n  \n  call <- match.call()\n  \n  type <- match.arg(type)\n\n  \n  if(missing(fitness))\n  { stop(\"A fitness function must be provided\") }\n  if(!is.function(fitness)) \n  { stop(\"A fitness function must be provided\") }\n  if(popSize < 10) \n  { warning(\"The population size is less than 10.\") }\n  if(maxiter < 1) \n  { stop(\"The maximum number of iterations must be at least 1.\") }\n  if(elitism > popSize) \n  { stop(\"The elitism cannot be larger that population size.\") }\n  if(pcrossover < 0 | pcrossover > 1)\n  { stop(\"Probability of crossover must be between 0 and 1.\") }\n  if(is.numeric(pmutation))\n  { if(pmutation < 0 | pmutation > 1)\n  { stop(\"If numeric probability of mutation must be between 0 and 1.\") }\n  else if(!is.function(population))\n  { stop(\"pmutation must be a numeric value in (0,1) or a function.\") }\n  }\n  if(missing(min) & missing(max) & missing(nBits))\n  { stop(\"A min and max range of values (for 'real-valued' or 'permutation' GA) or nBits (for 'binary' GA) must be provided!\") }\n  \n  switch(type, \n         \"binary\"      = { nBits <- as.vector(nBits)[1]\n                           #min <- max <- NA\n                           nvars <- nBits \n         },\n         \"real-valued\" = { min <- as.vector(min)\n                           max <- as.vector(max)\n                           nBits <- NA\n                           if(length(min) != length(max))\n                           { stop(\"min and max must be vector of the same length!\") }\n                           nvars <- length(max) \n         },\n         \"permutation\" = { min <- as.vector(min)[1]\n                           max <- as.vector(max)[1]\n                           nBits <- NA\n                           nvars <- length(seq(min,max)) \n         }\n  )\n  \n  \n \n  #Define Fitness as a matrix, in MESDIF, each value of objectives is evaluated individually\n  Fitness <- matrix(NA, nrow = popSize + elitism, ncol = 4)\n  #This counts the number of indivuals that are dominated by this one\n  Dominados <- numeric(popSize + elitism)\n  \n  \n  object <- new(\".ga\", \n                call = call, \n                type = type,\n                min = min, \n                max = max, \n                nBits = nBits, \n                names = if(is.null(names)) character() else names,\n                popSize = popSize,\n                iter = 0, \n                run = 1, \n                maxiter = maxiter,\n                suggestions = matrix(),\n                population = matrix(), \n                elitism = elitism, \n                pcrossover = pcrossover, \n                pmutation = if(is.numeric(pmutation)) pmutation else NA,\n                fitness = Fitness, \n                summary = matrix(),\n                bestSol = list())\n  \n  #This GA runs until a number of evaluations is reached, not iterations !\n  n_evals <- 0\n  if(!is.null(seed)) set.seed(seed)\n  \n  #Compute the number of genes, the mutation probability is applied over the gene.\n  if(!DNFRules)\n    nGenes <- nvars * popSize\n  else\n    nGenes <- (length(max) - 1) * popSize\n  \n  numMutaciones <- floor(pmutation * nGenes)\n  \n  object@DNFRules <- DNFRules\n  object@maxValuesRule <- max \n  object@popNew <- matrix(as.double(NA), nrow = popSize, ncol = nvars)\n  \n  # generate beginning population and elite population\n  Pop <- matrix(as.double(NA), nrow = popSize, ncol = nvars)\n  elitePop <- matrix(as.double(NA), nrow = elitism, ncol = nvars)\n  \n  #Sets the next gene to mute\n  Mu_next <- ceiling(log(runif(1)) / log(1 - pmutation))\n\n  \n  \n\n\n  # fill the rest with a random population\n   if( ! DNFRules) \n    Pop[1:popSize,] <- population(object, 0.25, round(nvars*0.25))[1:popSize,]\n    else \n      Pop[1:popSize,] <- population(object, 0.25, round((length(max) - 1)*0.25))[1:popSize,]\n\n  object@population <- Pop\n  \n  NonDominated <- logical(popSize + elitism) #Indicate wheter an individual is non-dominated\n  WhoDominateMe <- vector(mode = \"list\", length = popSize + elitism) #Indicate the inviduals which domain this one\n # AdaptationValue <- numeric(popSize + elitism) \n  \n  dots <- list(...) #Catch dots arguments\n  nObjs <- length( which(!is.na(dots[[9]])) ) - 1\n  \n  volumenEsfera <- .volSphere(nObjs)\n  \n  \n  nvariables <- nvars\n  # start iterations\n  for(iter in seq_len(maxiter))\n  {\n    #Create the union of this two populations and reinitializate all values\n    NonDominated[] <- FALSE\n    Dominados[] <- 0\n    \n    UnionPop <- matrix(NA, nrow = popSize + elitism, ncol = nvariables)\n   \n    UnionPop[seq_len(NROW(Pop)), ] <- Pop\n    UnionPop[(NROW(Pop) + 1):NROW(UnionPop),] <- elitePop\n    \n    #normalize DNF RULES\n#     if(DNFRules){\n#       UnionPop <- matrix(unlist(apply(X = UnionPop, MARGIN = 1, FUN = .normalizeDNFRule, max)), ncol = nBits, byrow = TRUE)\n#     }\n    \n    #Remove duplicated individuals in the UnionPop\n    UnionPop <- na.exclude(UnionPop)\n    duplicados <- which(! duplicated(UnionPop))\n    UnionPop <- UnionPop[duplicados, , drop = F]\n    Fitness <- Fitness[duplicados, , drop = F]\n\n\n    # evalute fitness function (when needed) \n\n    for(i in seq_len( NROW(UnionPop) ))\n      if(all(is.na(Fitness[i,])))\n      { Fitness[i,] <- fitness(UnionPop[i,], ...) \n        n_evals <- n_evals + 1} \n    \n    \n\n#Compute dominated and non-dominated rules and initial adaptation Value\n#Numero de individuos a los que domina cada regla\nf <- na.exclude(Fitness)[, seq_len(nObjs), drop = F]\nn_Ind <- NROW(f)\nfor(i in seq_len(n_Ind)){\n  nd <- apply(X = f, MARGIN = 1, FUN = function(x, regla){ all(regla <= x) & any(regla < x)}, f[i,])\n  Dominados[i] <- sum( apply(X = f, MARGIN = 1, FUN = function(x, regla){ all(regla >= x) & any(regla > x)}, f[i,]) )\n  NonDominated[i] <- all( ! nd )\n  WhoDominateMe[[i]] <- which(nd)\n}\n\n#Initial Adaptation Value\nAdaptationValue <- vapply(X = WhoDominateMe[seq_len(n_Ind)], FUN = function(x, dominados) sum(dominados[x]) ,  FUN.VALUE = 2, Dominados)\nkthDistances <- numeric(length(AdaptationValue))\n#Distance measurement (Distancia entre valores de la regla o entre valores de fitnes? Uso valores DE FITNESS)\ndistancia <- as.matrix( dist(x = f, method = \"euclidean\", upper = TRUE, diag = TRUE))^2\n\n#Order distance (The first colum is the distance with respect himself !! )\n# And calculate the final adaptation value for each rule\nkTH <- floor( sqrt(n_Ind - 1) )\nfor(i in seq_len(NROW(distancia))){\n  distancia[i,] <- distancia[i, order(distancia[i, ]), drop = F]\n  \n  #Gets k-th closest neighbor , in this case, k = sqrt(popSize - 1)\n  if(distancia[i, kTH] == 0){\n    #If k-th closest is 0, get the next closest greater than 0\n    aux <- distancia[i, (kTH + 1):ncol(distancia)] > 0\n    closest <- which(aux, useNames = F)\n    if(length(closest) > 0)\n      dist <- distancia[i, closest[1] + kTH]\n    else \n      #Exception: All individuals are equal\n      dist <- 1\n  } else {\n    dist <- distancia[i, kTH]\n  }\n  \n  kthDistances[i] <-  1 / dist^nObjs * kTH / n_Ind / volumenEsfera\n}\n\n#Normalize kthDistances\nkthDistances <- kthDistances / sum(kthDistances)\nAdaptationValue <- AdaptationValue + kthDistances\n  \n  \n  \n#Fill elite population\n#Compute the number of non-dominated individuals\ncantidadNoDominados <- sum(NonDominated)\n\nif( cantidadNoDominados <= elitism){\n  \n  #Adition operator (Incluye los elitism mejores valores de adaptacion  a la poblacion elite)\n  eliteIndividuals <- order(AdaptationValue)[seq_len(elitism)]\n  elitePop <- UnionPop[eliteIndividuals, , drop = F]\n \n} else {\n  #Truncation operator\n  lista <- .truncOperator(NonDominatedPop = UnionPop[which(NonDominated), , drop = F], elitePopSize = elitism, FitnessND = Fitness[which(NonDominated), , drop =  F])\n  elitePop <- lista[[1]]\n  eliteIndividuals <- which(NonDominated)[lista[[2]]]\n  \n  } \n\n# update object\nobject@iter <- iter\nobject@population <- Pop\nobject@fitness <- Fitness\n\n\n\n# check stopping criteria\n\nif(n_evals >= run) break  \nif(max(Fitness, na.rm = TRUE) >= maxfitness) break\nif(object@iter == maxiter) break  \n\n\n# selection by Binary Tournament (Adaptation Values is the value for the \"fitness\")\n#Copy the selected populatin into an intermediary population\nsel <- selection(elitePop, popSize, nvariables, AdaptationValue[eliteIndividuals], Fitness[eliteIndividuals, , drop = F])\ninterPop <- sel$population\nAdaptationValue <- sel$fitness\nFitness <- sel$obj\n\nobject@population <- interPop\n\n\n# crossover performed by a double-point crossover\n      if(pcrossover > 0)\n        { \n          nmating <- round( (popSize/2) * pcrossover )\n          \n          #Create the population where we allocate the descendents from crossover and mutation\n          descPop <- matrix(NA, ncol = nvariables, nrow = popSize*2)\n          \n          #mating <- matrix(sample(seq_len(popSize), size = (2*nmating), replace = TRUE), ncol = 2, byrow = T)\n          for(i in seq_len(nmating))\n            { \n                parents <- sample(seq_len(popSize), size = 2, replace = TRUE)\n                Crossover <- crossover(object, parents)\n                descPop[c(2*i - 1, 2*i),] <- Crossover$children\n              \n                \n            }             \n          #object@population <- descPop\n          #nGenes <- NROW(na.exclude(descPop)) * nvariables\n        }\n\n# mutation (only .mutate popLength * probMut chromosomes)\npm <- pmutation\nif(DNFRules) nvars <- length(max) - 1\nif(pm > 0)\n{ \n\nsuma <- nmating*2 + 1\nwhile(Mu_next <= nGenes){\ncromosoma <- ceiling( Mu_next  / nvars ) \ngen <- (Mu_next %% nvars) + 1\n\ndescPop[suma, ] <- mutation(object, cromosoma, gen)\nsuma <- suma + 1\n#Calcuate next gene\nMu_next <- Mu_next + ceiling(log( runif(1) ) /  log(1 - pmutation))\n}\n\nMu_next <- Mu_next - nGenes\n\n\n#Replace the worst individuals in the population with the genereted in crossovers and mutations\n\norden <- order(AdaptationValue)\n#orden <- .qsort(AdaptationValue, left = 1, right = length(AdaptationValue), index = seq_len(length(AdaptationValue)))\n#orden <- orden$indices\nPop <- interPop#[orden, , drop = F]\norden <- c(orden, (popSize+1):NROW(Fitness))\n#Fitness <- Fitness[orden,, drop = F] \n\n\nPop[orden[popSize:(popSize - (suma - 2))], ] <- descPop[seq_len(suma - 1),]\nFitness[orden[popSize:(popSize - (suma - 2))], ] <- NA\n\n  \n  }\n}\n\n# Return Non-duplicated individuals in elite pop\n  if(DNFRules){\n    elitePop <- matrix(unlist(apply(X = elitePop, MARGIN = 1, FUN = .normalizeDNFRule, max)), ncol = nBits, byrow = TRUE)\n    } \n    elitePop[which(!duplicated(elitePop)), , drop = F]\n  \n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#\n#\n# Genetic algorithm for NMEEF-SD\n#\n#\n\n.gaNMEEF <- function(type = c(\"binary\", \"real-valued\", \"permutation\"), \n                     fitness, ...,\n                     min, max, nBits,\n                     population ,\n                     selection ,\n                     crossover , \n                     mutation ,\n                     popSize = 50, \n                     pcrossover = 0.8, \n                     pmutation = 0.1, \n                     elitism = base::max(1, round(popSize*0.05)), \n                     maxiter = 100,\n                     run = maxiter,\n                     maxfitness = Inf,\n                     names = NULL,\n                     suggestions = NULL, \n                     keepBest = FALSE,\n                     parallel = FALSE,\n                     monitor = NULL,\n                     DNFRules = FALSE,\n                     seed = NULL,\n                     porcCob = 0.5,\n                     StrictDominance = TRUE,\n                     reInitPop = TRUE, \n                     minCnf = 0.6) \n{\n  \n  call <- match.call()\n  \n  type <- match.arg(type)\n\n  \n  if(missing(fitness))\n  { stop(\"A fitness function must be provided\") }\n  if(!is.function(fitness)) \n  { stop(\"A fitness function must be provided\") }\n  if(popSize < 10) \n  { warning(\"The population size is less than 10.\") }\n  if(maxiter < 1) \n  { stop(\"The maximum number of iterations must be at least 1.\") }\n  if(elitism > popSize) \n  { stop(\"The elitism cannot be larger that population size.\") }\n  if(pcrossover < 0 | pcrossover > 1)\n  { stop(\"Probability of crossover must be between 0 and 1.\") }\n  if(is.numeric(pmutation))\n  { if(pmutation < 0 | pmutation > 1)\n  { stop(\"If numeric probability of mutation must be between 0 and 1.\") }\n    else if(!is.function(population))\n    { stop(\"pmutation must be a numeric value in (0,1) or a function.\") }\n  }\n  if(missing(min) & missing(max) & missing(nBits))\n  { stop(\"A min and max range of values (for 'real-valued' or 'permutation' GA) or nBits (for 'binary' GA) must be provided!\") }\n  \n  switch(type, \n         \"binary\"      = { nBits <- as.vector(nBits)[1]\n         #min <- max <- NA\n         nvars <- nBits \n         },\n         \"real-valued\" = { min <- as.vector(min)\n         max <- as.vector(max)\n         nBits <- NA\n         if(length(min) != length(max))\n         { stop(\"min and max must be vector of the same length!\") }\n         nvars <- length(max) \n         },\n         \"permutation\" = { min <- as.vector(min)[1]\n         max <- as.vector(max)[1]\n         nBits <- NA\n         nvars <- length(seq(min,max)) \n         }\n  )\n  \n  \n  \n  #Define Fitness as a matrix, in NMEEF, each value of objectives is evaluated individually\n  Fitness <- matrix(NA, nrow = popSize * 2, ncol = 4)\n\n  \n  \n  object <- new(\".ga\", \n                call = call, \n                type = type,\n                min = min, \n                max = max, \n                nBits = nBits, \n                names = if(is.null(names)) character() else names,\n                popSize = popSize,\n                iter = 0, \n                run = 1, \n                maxiter = maxiter,\n                suggestions = matrix(),\n                population = matrix(), \n                elitism = elitism, \n                pcrossover = pcrossover, \n                pmutation = if(is.numeric(pmutation)) pmutation else NA,\n                fitness = Fitness, \n                summary = matrix(),\n                bestSol = list())\n  #This GA runs until a number of EVALUATIONS is reached, not iterations !\n  n_evals <- 0\n  if(!is.null(seed)) set.seed(seed)\n  \n  \n  #Compute the number of genes, the mutation probability is applied over the gene.\n  if(!DNFRules)\n    nGenes <- nvars * popSize\n  else\n    nGenes <- (length(max) - 1) * popSize\n  \n  \n  #Set the next gene to mute\n  numMutaciones <- round(pmutation * nGenes)\n  \n  object@DNFRules <- DNFRules\n  object@maxValuesRule <- max \n  object@popNew <- matrix(as.double(NA), nrow = popSize, ncol = nvars)\n  \n  # generate beginning population and Offspring pop\n  Pop <- matrix(as.integer(NA), nrow = popSize, ncol = nvars)\n  OffspringPop <- matrix(as.integer(NA), nrow = popSize, ncol = nvars)\n  UnionPop <- matrix(as.integer(NA), nrow = popSize *2, ncol = nvars)\n  \n \n  if( ! DNFRules) \n    Pop[1:popSize,] <- population(object, 0.25, round(nvars*0.25))#[1:(popSize-ng),]\n  else \n    Pop[1:popSize,] <- population(object, 0.25, round((length(max) - 1)*0.25))#[1:(popSize,]\n  \n  object@population <- Pop\n  \n  #This counts the number of indivuals that domain this one\n  Dominados <- numeric(popSize *2)\n  WhoIDomain <- vector(mode = \"list\", length = popSize *2) #Indicate the inviduals which are dominated by this one\n  rank <- numeric(popSize * 2) #Inidicate the rank of the individual\n  CrowdingDistance <- numeric(popSize * 2) #Indicate the crowding distance of the individual\n  dots <- list(...) #Catch dots arguments\n  nObjs <- sum(! is.na(dots[[9]])) - 1 # Number of objetives we are using. -1 because the last value indicate te use of dnf or can representation for fitness calc.\n  frentes <- vector(mode = \"list\", length = popSize * 2)\n  fitnessFrentes <- vector(mode = \"list\", length = popSize * 2)\n  coveredByIndividualFrentes <- vector(mode = \"list\", length = popSize * 2)\n  coveredByIndividual <- matrix(FALSE, ncol = popSize * 2, nrow = length( dots[[1]][[\"data\"]] ))\n  cubiertoActual <- cubiertoAnterior <- logical(length( dots[[1]][[\"data\"]] ))\n  nIterEvolve <- 0 #Evaluation where the population evolved the last time\n  fivePercent <- floor(run * 0.05)\n  nvariables <- nvars\n  dataset <- matrix(unlist(dots[[1]][[\"data\"]]), nrow = nvariables + 1)\n  targetClass <- which(dots[[1]][[\"class_names\"]] == dots[[3]]) - 1\n  \n  \n \n  #Evaluation of pop\n  for(i in seq_len( NROW(Pop) ))\n    if(all(is.na(Fitness[i,]))){\n      fit <- fitness(Pop[i,], ...) \n      Fitness[i,] <- fit[[1]]\n      coveredByIndividual[,i] <- as.logical(fit[[2]])\n      n_evals <- n_evals + 1\n    } \n  \n  \n  # start iterations\n  for(iter in seq_len(maxiter))\n  {\n    #reinitialize all values\n\n\n    UnionPop[] <- NA\n    OffspringPop[] <- NA\n    \n    \n    \n    \n    #Check stopping criteria\n    if(n_evals >= run) break  \n    if(max(Fitness, na.rm = TRUE) >= maxfitness) break\n    if(object@iter == maxiter) break  \n    \n    frentes <- vector(mode = \"list\", length = popSize * 2)\n    \n    # selection by Binary Tournament \n    # Copy the selected populatin into the offspring population\n \n    sel <- selection(Pop, popSize, rank, CrowdingDistance, Fitness, coveredByIndividual) \n    OffspringPop <- sel[[1]]\n    FitnessOffspring <- sel[[2]]\n    coveredByIndividual[,(popSize + 1):(popSize*2)] <- sel[[3]]\n   \n    \n    object@population <- OffspringPop\n   \n    # crossover performed by a double-point crossover on Offspring Pop\n    if(pcrossover > 0)\n    { \n      nmating <- round( (popSize/2) * pcrossover )\n      \n      #mating <- matrix(sample(seq_len(popSize), size = 2*popSize, replace = TRUE), ncol = 2)\n      mating <- matrix(sample(seq_len(popSize), size = floor(popSize/2) * 2, replace = TRUE), ncol = 2)\n      equals <- which(mating[,1] == mating[,2])\n      \n      while(length(equals) > 0){\n        mating[equals,] <- matrix(sample(seq_len(popSize), size = 2*length(equals), replace = TRUE), ncol = 2)\n        equals <- which(mating[,1] == mating[,2])\n      }\n      \n      #throw popSize/2 random numbers\n      dados <- runif(floor(popSize/2))\n    \n      \n      #Check which pair of individuals cross\n      mating <- mating[which(dados <= pcrossover), , drop = F]\n    \n      for(i in seq_len(NROW(mating)))\n      { \n        parents <- mating[i,]\n        Crossover <- crossover(object, parents)\n        OffspringPop[parents,] <- Crossover$children\n        FitnessOffspring[parents,] <- NA\n        \n      }             \n    \n      object@population <- OffspringPop\n      nGenes <- NROW(na.exclude(OffspringPop)) * nvariables\n      \n    }\n    \n    # mutation \n    pm <- pmutation\n    if(DNFRules) nvars <- length(max) - 1\n    if(pm > 0)\n    { \n      dados <- runif(nGenes)\n   \n      \n      genes <- which(dados <= pmutation)\n     \n      cromosomas <- ceiling(genes / nvariables)\n      vars <- (genes %% nvariables) + 1\n      \n      for(i in seq_len(length(vars))) \n      {     \n        object@population[cromosomas[i],] <- mutation(object, cromosomas[i], vars[i])\n      }\n    \n      OffspringPop <- object@population\n      \n      FitnessOffspring[cromosomas,] <- NA\n    \n      \n    }\n    \n    #Copy FitnessOffspring and evaluate individuals crossed and mutated\n    Fitness[(NROW(Pop) + 1):(popSize*2), ] <- FitnessOffspring\n  \n    \n   #Generate the next population.\n    \n    #Combine Pop and  OffspringPop into UnionPop\n    \n    UnionPop[seq_len(NROW(Pop)), ] <- Pop\n    UnionPop[(NROW(Pop) + 1):NROW(UnionPop), ] <- OffspringPop\n    #Evaluation of pop\n    for(i in (NROW(Pop) + 1):(popSize*2) )\n      if(all(is.na(Fitness[i,]))){\n        fit <- fitness(UnionPop[i,], ...) \n        Fitness[i,] <- fit[[1]]\n        coveredByIndividual[,i] <- as.logical( fit[[2]] )\n        n_evals <- n_evals + 1\n      } \n   \n  #Compute dominance values for performing fast sorting algorithm\n    f <- na.exclude(Fitness)[,seq_len(nObjs),drop=F]\n    n_Ind <- NROW(f)\n    for(i in seq_len(n_Ind)){\n      nd <- apply(X = f, MARGIN = 1, FUN = .calculateDominance, f[i,,drop=F], StrictDominance) #SangrÃ­a\n      Dominados[i] <- length(which(nd == 1L))\n      WhoIDomain[[i]] <- which(nd <= 0L)\n    }\n    \n    #Get the Pareto front\n    frentes[[1]] <- which(Dominados == 0)\n    \n    #Order UnionPop by dominance fronts (fast sorting algorithm)\n    p <- 1\n    while(length(frentes[[p]]) != 0){\n      p <- p+1\n      \n      for(i in frentes[[p - 1]]){\n        \n       if(length(WhoIDomain[[i]] > 0)){\n        Dominados[ WhoIDomain[[i]] ] <- Dominados[ WhoIDomain[[i]] ] - 1\n        alSaco <-  which(Dominados == 0)\n        if(length(alSaco) > 0){\n          frentes[[p]] <- c(frentes[[p]], alSaco)\n          rank[alSaco] <- p-1\n        }\n       } \n      } \n\n    }\n\n  \n    #Check if non-dominated front covers new examples and evolve\n    enElFrente <- frentes[[1]]\n    cubiertoActual <- apply(X = coveredByIndividual[, enElFrente, drop = F], MARGIN = 1, FUN = any)\n    \n    #Check if there are new examples covered \n    evolve <- any(! cubiertoAnterior[which(cubiertoActual)])\n    \n\n    \n    for(i in seq_len(p - 1)){\n      fitnessFrentes[[i]] <- Fitness[frentes[[i]], ,drop = F]\n      coveredByIndividualFrentes[[i]] <- coveredByIndividual[,frentes[[i]], drop = F]\n      frentes[[i]] <- UnionPop[frentes[[i]], , drop = F]\n      \n    }\n\n      if(evolve){\n        nIterEvolve <- n_evals\n      } \n    cubiertoAnterior <- cubiertoActual\n    \n      # fill the next population \n      aux <- .fillPopulation(frentes, p - 1, fitnessFrentes, coveredByIndividualFrentes, popSize, nObjs)\n      Pop <- aux[[1]]\n      CrowdingDistance[seq_len(popSize)] <- aux[[2]]\n      Fitness[seq_len(popSize), ] <- aux[[3]]\n      rank <- aux[[4]]\n      coveredByIndividual <- aux[[5]]\n      \n      # Checks if we need to reinitialize the population\n      if(! evolve & ! aux[[6]] & reInitPop){\n      # Check reinit condicion\n      if(n_evals - nIterEvolve >= fivePercent){\n        \n        #re-initialize population\n    \n        #sel <- .reInitPob(elitePop = frentes[[1]], fitnessElite = fitnessFrentes[[1]], coveredElite = coveredByIndividual[,enElFrente], calculateDominance = CrowdingDistance, pctVariables = 0.5, cubiertoActual = cubiertoActual, dataset = dataset, maxRegla = dots[[1]][[\"conjuntos\"]], cate = dots[[14]], num = dots[[15]], crispSets = dots[[1]][[\"crispSets\"]], targetClass = targetClass, popSize = popSize )\n        sel <- .reInitPob(elitePop = Pop, fitnessElite = Fitness[seq_len(popSize), ], coveredElite = coveredByIndividual[, seq_len(popSize)], crowdingDistance = CrowdingDistance, pctVariables = porcCob, cubiertoActual = cubiertoActual, dataset = dataset, maxRegla = dots[[1]][[\"conjuntos\"]], cate = dots[[14]], num = dots[[15]], crispSets = dots[[1]][[\"crispSets\"]], targetClass = targetClass, popSize = popSize )\n        Pop <- sel[[1]]\n        Fitness <- sel[[2]]\n        CrowdingDistance <- sel[[3]]\n        coveredByIndividual[,seq_len(popSize) ] <- sel[[4]]\n        \n        #Evaluation of generated pop\n        for(i in seq_len(popSize) )\n          if(all(is.na(Fitness[i,]))){\n            fit <- fitness(Pop[i,], ...) \n            Fitness[i,] <- fit[[1]]\n            coveredByIndividual[,i] <- as.logical( fit[[2]] )\n            newCovered <- which(! cubiertoAnterior[which(as.logical( fit[[2]] ))]) # Check if this rule covers new uncovered examples\n            n_evals <- n_evals + 1\n            if(length(newCovered) > 0){\n              nIterEvolve <- n_evals\n              cubiertoAnterior[newCovered] <- TRUE\n            }\n          }\n        \n        #Check if new population evolve\n        cubiertoActual <- apply(X = coveredByIndividual[, enElFrente, drop = F], MARGIN = 1, FUN = any)\n        evolve <- any(! cubiertoAnterior[which(cubiertoActual)])\n        cubiertoAnterior <- cubiertoActual\n        \n        if(evolve)\n          nIterEvolve <- n_evals\n         \n        rank[] <- 0\n        \n      }\n      }\n    \n      object@population <- Pop\n      object@fitness <- Fitness\n    \n  }\n  \n  \n  \n  \n  #get the last ranking\n  \n  #Compute dominance values\n  f <- na.exclude(Fitness)[1:popSize,seq_len(nObjs), drop = F]\n  n_Ind <- NROW(f)\n  for(i in seq_len(n_Ind)){\n    nd <- apply(X = f, MARGIN = 1, FUN = .calculateDominance, f[i,], TRUE)\n    Dominados[i] <- length(which(nd == 1L))\n    WhoIDomain[[i]] <- which(nd <= 0L)\n  }\n  \n  #Get the Pareto front\n  frentes[[1]] <- which(Dominados == 0)\n  frentes[[1]] <- Pop[frentes[[1]], , drop = F]\n\n  \n  #Return individuals of the Pareto that has more confidence than the minimum.\n  unicos <- which(!duplicated(frentes[[1]]))\n  frentes[[1]] <- frentes[[1]][unicos, , drop = F]\n  \n  #Evaluate indivuduals for getting fuzzy confidence\n  dots[[9]] <- list(.confianzaDifusa, NA, NA, FALSE)\n  \n  for(i in seq_len(NROW( frentes[[1]])) ){\n      fit <- fitness(frentes[[1]][i,], dots[[1]],dots[[2]],dots[[3]],dots[[4]],dots[[5]],dots[[6]],dots[[7]],dots[[8]],dots[[9]],dots[[10]],dots[[11]],dots[[12]],dots[[13]],dots[[14]],dots[[15]],dots[[16]]) \n      Fitness[i,4] <- fit[[1]][1]\n  }\n  \n  frentes[[1]] <- frentes[[1]][which(Fitness[seq_len(NROW(frentes[[1]])),4] > minCnf), , drop = F]\n  frentes[[1]] #Return\n  \n}\n\n\n\n\n\n\n\n#\n#\n#  FuGePSD Genetic Algorithm\n#\n#\n\n.gaFuGePSD <- function(type,           # Type of execution (1 for One vs All, != 1 for normal execution)\n                       dataset,        # keel object asociated to this genetic Algorithm (training file)\n                       selection ,     # Selection function !\n                       crossover ,     # Crossover function !\n                       mutation ,      # mutation function\n                       popSize = 50,      #size of the population\n                       pcrossover = 0.8,  #Crossover Probability\n                       pmutation = 0.1,   #Mutation Probability\n                       pinsertion = 0.05,    #Insertion Probability\n                       pdropping = 0.05,     #Dropping Probability\n                       selectionSize = 2, #Tournament selection size\n                       AllClass = TRUE,   #ALL_CLASS Attribute\n                       T_norm = 1,        # T-norm used\n                       ruleWeight = 0 ,    # Rule Weighting method to use\n                       frm = 0,           # Fuzzy Reasoning Method to use\n                       maxiter = 100,    #Max generations to run this genetic Algorithm.\n                       weightsGlobalFitness = c(0.25, 0.25, 0.25, 0.25), #Weights Used in population Global Evaluation\n                       seed = .randInt(0, 20000000)\n                      )\n{\n  #First of all, we must check types of all attributes\n  if(class(dataset) != \"keel\")\n    stop(\"'dataset' must be a keel dataset object.\")\n  if(! is.function(selection))\n    stop(\"'selection' must be function.\")\n  if(! is.function(crossover))\n    stop(\"'crossover' must be function.\")\n  if(! is.function(mutation))\n    stop(\"'mutation' must be function.\")  \n  if(popSize <= 0)\n    stop(\"'popSize' must be greater than zero.\")\n \n  if(selectionSize < 2)\n    stop(\"'selectionSize' must be greater than 2.\")\n  if(! is.logical(AllClass))\n    stop(\"'AllClass' must be a logical value.\")\n  if(maxiter < 1)\n    stop(\"'maxiter' must be greater than zero\")\n\n  if(length(weightsGlobalFitness) != 4)\n    stop(\"length of 'weightsGlobalFitness' must be 4\")\n  \n  suma <- sum(pcrossover, pmutation, pinsertion, pdropping)\n  if(suma != 1 ){\n    pcrossover <- pcrossover / suma\n    pmutation <- pmutation / suma\n    pinsertion <- pinsertion / suma\n    pdropping <- pdropping / suma\n  }\n  \n  #Once checked, the evolutive process can start\n  if(type == 0){\n    #Execution One Vs all\n    \n  } else {\n    #Normal execution and Return\n    executionPSD( clas = NULL,\n                  dataset,        \n                  selection ,    \n                  crossover ,     \n                  mutation ,      \n                  popSize,      \n                  pcrossover, \n                  pmutation ,  \n                  pinsertion,    \n                  pdropping ,     \n                  selectionSize, \n                  AllClass,   \n                  T_norm,       \n                  ruleWeight,    \n                  frm,           \n                  maxiter,   \n                  weightsGlobalFitness,\n                  seed)\n  }\n  \n}\n\n\n\nexecutionPSD <- function(clas = NULL,   # number of the class to generate rules.\n                       dataset,        # keel object asociated to this genetic Algorithm (training file)\n                       selection ,     # Selection function !\n                       crossover ,     # Crossover function !\n                       mutation ,      # mutation function\n                       popSize = 50,      #size of the population\n                       pcrossover = 0.8,  #Crossover Probability\n                       pmutation = 0.1,   #Mutation Probability\n                       pinsertion = 0.05,    #Insertion Probability\n                       pdropping = 0.05,     #Dropping Probability\n                       selectionSize = 2, #Tournament selection size\n                       AllClass = TRUE,   #ALL_CLASS Attribute\n                       T_norm = 1,        # T-norm used\n                       ruleWeight = 0 ,    # Rule Weighting method to use\n                       frm = 0,           # Fuzzy Reasoning Method to use\n                       maxiter = 100,    #Max generations to run this genetic Algorithm.\n                       weightsGlobalFitness = c(0.25, 0.25, 0.25, 0.25), #Weights Used in population Global Evaluation\n                       seed = .randInt(0, 20000000)\n){\n  populationFitness <- bestPopulationFitness <- numeric(1)\n  exampleClass <- unlist(.getClassAttributes(dataset$data))\n  \n  #get categorical and numerical variables\n  categorical <- dataset$atributeTypes == \"c\"\n  categorical <- categorical[-length(categorical)]\n  numerical <- !categorical\n  \n  datasetNoClass <- matrix(unlist(.separar(dataset)), nrow = dataset$nVars, ncol = dataset$Ns)\n  bestPop <- vector(mode = \"list\", length = popSize)\n  \n  #Init population\n  pop <- lapply(seq_len(popSize), function(x, dataset, tnorm, tconorm, rule_weight, clase){\n    createNewRule(dataset, tnorm, tconorm, rule_weight, clase)\n  }, dataset, T_norm, T_norm, ruleWeight, clas)\n  \n  #evaluate initial population individuals (In parallel for Linux)\n  if(length(pop) >= 20 & Sys.info()[1] == \"Linux\"){\n    pop <- parallel::mclapply(pop, Rule.evaluate, dataset, datasetNoClass, categorical, numerical, T_norm, ruleWeight, mc.cores = parallel::detectCores())\n  } else {\n   pop <- lapply(pop, Rule.evaluate, dataset, datasetNoClass, categorical, numerical, T_norm, ruleWeight)\n  }\n  #evaluate the whole population\n  populationFitness <- Pop.evaluate(pop, dataset, datasetNoClass, exampleClass, frm, categorical, numerical, T_norm, weightsGlobalFitness)\n  \n  #best population is now initial population.\n  bestPop <- pop\n  bestPopulationFitness <- populationFitness\n  cat(paste(\"Global Fitness obtained in generation [0]:\", bestPopulationFitness, \"\\n\", sep = \" \"))\n  \n  \n  \n  #Init the evolutive process\n  for(generation in seq_len(maxiter - 1)){\n    #First, create a join population with twice length of population. Then add pop to joinPop\n    joinPop <- vector(mode = \"list\", length = length(pop) * 2)\n    joinPop[seq_len(length(pop))] <- pop\n    \n    #Now we need to generate an offspring population length equal to pop length.\n    #This offspring population is generated via genetic operators.\n    \n    dados <- runif(length(pop))\n    first_parents <- vapply(X = seq_len(length(pop)), \n                            FUN = function(x, pop, tam){\n                                  tournamentSelection(pop, tam)}, numeric(1), pop, selectionSize)\n    \n    #Specify the genetic operator to apply according to their probability in 'dados'\n    cruzan <- first_parents[which(dados < pcrossover)]\n    mutan <- first_parents[which(pcrossover <= dados & dados < (pcrossover + pmutation))]\n    insertan <- first_parents[which((pcrossover + pmutation) <= dados & dados < (pcrossover + pmutation + pinsertion))]\n    dropean <- first_parents[which(pcrossover + pmutation + pinsertion <= dados)]\n    \n    posJoinPop <- length(pop) + 1\n    #Make crossovers\n    for(i in cruzan){\n      second_parent <- .randIntExcluded(1, length(pop), i)\n      joinPop[[posJoinPop]] <- FuGePSD_crossover(rule1 = pop[[i]], rule2 = pop[[second_parent]], nvars = dataset$nVars + 1)\n      posJoinPop <- posJoinPop + 1  \n    }\n    \n    #Make mutations \n    for(i in mutan){\n      joinPop[[posJoinPop]] <- FuGePSD_Mutation(pop[[i]], dataset)\n      posJoinPop <- posJoinPop + 1\n    }\n    \n    #Make insertions\n    for(i in insertan){\n      if(length(pop[[i]][[1]]) == dataset[[6]]){ \n        #If we cannot add more variables, we introduce a rule with an empty antecedent.\n        joinPop[[posJoinPop]] <- Rule.clearAntecedent(pop[[i]])\n      } else {\n        #Add a random variable\n        joinPop[[posJoinPop]] <- Rule.addVariable(pop[[i]], dataset)\n      }\n      posJoinPop <- posJoinPop + 1\n    }\n    \n    #Make droppings\n    for(i in dropean){\n      if(length(pop[[i]][[1]]) == 1){\n        #We cannot delete more variables, return an empty rule\n        joinPop[[posJoinPop]] <- Rule.clearAntecedent(pop[[i]])\n      } else {\n        joinPop[[posJoinPop]] <- Rule.deleteVariable(pop[[i]])\n      }\n      posJoinPop <- posJoinPop + 1\n    }\n    \n    #Evaluate joinPop.\n    joinPop <- lapply(joinPop, Rule.evaluate, dataset, datasetNoClass, categorical, numerical, T_norm, ruleWeight)\n    \n    #Apply Token Competition\n    pop <- tokenCompetition(joinPop, dataset)\n    \n    #Evaluate Global Fitness\n    populationFitness <- Pop.evaluate(pop, dataset, datasetNoClass, exampleClass, frm, categorical, numerical, T_norm, weightsGlobalFitness)\n    \n    #Substitute best population if actual if better.\n    if(bestPopulationFitness < populationFitness){\n      bestPopulationFitness <- populationFitness\n      bestPop <- pop\n      cat(paste(\"Global Fitness obtained in generation [\", generation, \"]: \", bestPopulationFitness, \"\\n\", sep = \"\"))\n    }\n    \n    #cat(\"\\r\", (generation / (maxiter-1)) * 100, \"% Completed.\", sep = \"\")\n  }\n  \n  #Order bestPop by conf_f (desc. order)\n  fuzzy_conf <- vapply(X = bestPop, FUN = function(x){x$qm_Cnf_f}, numeric(1))\n  sens <- vapply(X = bestPop, FUN = function(x){x$qm_Sens}, numeric(1))\n  orden <- order(fuzzy_conf, decreasing = TRUE)\n  fuzzy_conf <- fuzzy_conf[orden]\n  sens <- sens[orden]\n  \n  bestPop <- bestPop[orden]\n  \n  #Return \n  list(bestPop = bestPop, conf = fuzzy_conf, sensitivity = sens)\n\n}\n\n\n#-------------------------------------------------------------------------------\n# ---  THis part is part of the definition of the \"ga\" class done in the GA Package\n#--------------------------------------------------------------------------------\n#\n# We need to change this behaviour, we dont want to depend on this functions.\n# Because we dont use it.\n\n\n\nmethods::setClassUnion(\".numericOrNA\", members = c(\"numeric\", \"logical\", \"matrix\"))\n\nmethods::setClassUnion(\".matrixOrList\", members = c(\"matrix\", \"list\"))\n\n#Modification of the class 'ga' provided by the package \"GA\" created by Luca Scrucca.\n\nmethods::setClass(Class = \".ga\", \n         representation(call = \"language\",\n                        type = \"character\",\n                        min = \".numericOrNA\", \n                        max = \".numericOrNA\", \n                        nBits = \".numericOrNA\", \n                        names = \"character\",\n                        popSize = \"numeric\",\n                        iter = \"numeric\", \n                        run = \"numeric\", \n                        maxiter = \"numeric\",\n                        suggestions = \"matrix\",\n                        population = \".matrixOrList\",\n                        popNew = \"matrix\",\n                        elitism = \"numeric\", \n                        pcrossover = \"numeric\", \n                        pmutation = \".numericOrNA\",\n                        fitness = \".numericOrNA\",\n                        summary = \"matrix\",\n                        bestSol = \"list\",\n                        fitnessValue = \"numeric\",\n                        solution = \"matrix\",\n                        maxValuesRule = \".numericOrNA\",\n                        DNFRules = \"logical\"\n         ),\n         package = \"SDR\" \n) \n\n\n\n\n\n\n#---------------------------------------------------------------------------------------------\n\n\n\n\n\n\n\n## \n## Modification of Permutation ga operators.\n##  This modification generate an integer random population in the range[min, max]\n##\n\n.generarPoblacion <- function(object, ...)\n{\n  # Generate a random permutation of size popSize in the range [min, max]  \n  min <- object@min\n  max <- object@max\n  type <- object@type\n  size <- object@popSize\n  \n  \n  if(! object@DNFRules){ # real-valued indica que se usan reglas tipo CAN\n    population <- matrix(as.double(NA), nrow = size, ncol = length( max ) )\n    for(i in 1:size)\n      for(j in 1:length(max))\n        #Se genera la poblacion inicial, el valor de no participacion no cuenta ! \n        population[i,j] <- sample(0:(max[j]), size = 1, replace = TRUE)\n    \n  } else { # reglas DNF \n    v <- sample(x = c(0,1), size = max[length(max)] * size, replace = TRUE)\n    population <- matrix(data = v, nrow = size, ncol = max[length(max)],byrow = TRUE)\n  }\n  \n  return(population)\n}\n\n\n\n\n\n\n#  \n# GENERA LA POBLACION INICIAL PARA MESDIF\n# En el argumento ... deben de ir primero el porcentaje de poblacion que se genera completamente aleatorio\n# y en segundo lugar el numero maximo de variables que participan en la regla.\n.generarPoblacionMESDIF <- function(object, ...)\n{\n  # Generate a random permutation of size popSize in the range [min, max]  \n  min <- object@min\n  max <- object@max\n  type <- object@type\n  size <- object@popSize\n  lista <- list(...)\n  pctAleatorio <- lista[[1]]\n  numVarMax <- lista[[2]]\n  var_init <- logical(length(max))\n  \n  reglas <- ceiling(size * (1-pctAleatorio))\n  if(! object@DNFRules){ # real-valued indica que se usan reglas tipo CAN\n    population <- matrix(max, nrow = size, ncol = length( max ), byrow = TRUE )\n    # Biased Init\n    for(i in seq_len(reglas)){\n      var_init[] <- F\n      numVar <- sample(numVarMax, size = 1)\n      for(j in seq_len(numVar)){\n        var <- sample(length(max), size = 1)\n        while(var_init[var]){  #Hay que incluir esto tambien a reglas DNF\n          var <- sample(length(max), size = 1)\n        }\n        population[i, var] <- sample(0:(max[var]), size = 1, replace = TRUE) # No-Participate value is not into account\n        var_init[var] <- T\n        }\n    }\n    \n    \n    #Random Init\n    for(i in (reglas + 1):size){\n      \n      for(j in seq_len(length(max)))\n        \n        population[i,j] <- sample(0:(max[j]), size = 1, replace = TRUE)\n    }\n    \n    \n  } else { # reglas DNF \n    \n    # Random Init \n    v <- sample(x = c(0,1), size = max[length(max)] * size, replace = TRUE)\n    population <- matrix(data = v, nrow = size, ncol = max[length(max)],byrow = TRUE)\n    \n    #Biased Init\n    nReglasABorrar <- length(max) - 1 - numVarMax\n    for(i in (reglas + 1):size){\n      varia <- sample(length(max) - 1, size = nReglasABorrar, replace = FALSE)\n      for(j in seq_len(nReglasABorrar)){\n        population[i, ] <- .borrar_gen(regla = population[i,], variable = varia[j], max_valor_variables = max, DNF_Rules = TRUE)\n      }\n    }\n  }\n  return(population)\n}\n\n\n\n\n\n\n\n\n\n#\n# Generates the initial population of NMEEF-SD\n#\n\n.generarPoblacionNMEEF <- function(object, ...)\n{\n  # Generate a random permutation of size popSize in the range [min, max]  \n  min <- as.integer(object@min)\n  max <- as.integer(object@max)\n  type <- object@type\n  size <- object@popSize\n  lista <- list(...)\n  pctAleatorio <- lista[[1]]\n  numVarMax <- lista[[2]]\n  var_init <- logical(length(max))\n  \n  reglas <- ceiling(size * (1-pctAleatorio))\n  if(! object@DNFRules){ # real-valued indica que se usan reglas tipo CAN\n    population <- matrix(max, nrow = size, ncol = length( max ), byrow = TRUE )\n    # Biased Init\n    for(i in seq_len(reglas)){\n      var_init[] <- F\n      numVar <- sample(numVarMax, size = 1)\n      for(j in seq_len(numVar)){\n        var <- sample(length(max), size = 1)\n        while(var_init[var]){  #Hay que incluir esto tambien a reglas DNF\n          var <- sample(length(max), size = 1)\n        }\n        population[i, var] <- sample(0:(max[var] - 1), size = 1, replace = TRUE) # No-Participate value is not into account\n        var_init[var] <- T\n      }\n    }\n      \n      #Random Init\n      for(i in (reglas + 1):size){\n        \n        for(j in seq_len(length(max)))\n          \n          population[i,j] <- sample(0:(max[j]), size = 1, replace = TRUE)\n      }\n      \n  } else { # reglas DNF \n    \n    # Random Init \n    v <- sample(x = c(0,1), size = max[length(max)] * size, replace = TRUE)\n    population <- matrix(data = v, nrow = size, ncol = max[length(max)],byrow = TRUE)\n    \n    #Biased Init\n    nReglasABorrar <- length(max) - 1 - numVarMax\n    for(i in (reglas + 1):size){\n      varia <- sample(length(max) - 1, size = nReglasABorrar, replace = FALSE)\n      for(j in seq_len(nReglasABorrar)){\n        population[i, ] <- .borrar_gen(regla = population[i,], variable = varia[j], max_valor_variables = max, DNF_Rules = TRUE)\n      }\n    }\n  }\n\n  return(population)\n}\n\n\n\n\n\n\n\n\n\n#\n# Double-point crossover\n#\n.ga_dpCrossover <- function(object, parents, ...)\n{\n\n\n  if( ! object@DNFRules){ #REGLAS CAN\n     \n      parents <- object@population[parents,,drop = FALSE]\n      n <- ncol(parents)\n      children <- matrix(as.double(NA), nrow = 2, ncol = n)\n      fitnessChildren <- rep(NA, 2)\n      crossOverPoint1 <- sample(seq_len(n), size = 1, replace = TRUE)  \n      if(crossOverPoint1 == (n) )\n      { crossOverPoint2 <- n   } else {\n      crossOverPoint2 <- sample((crossOverPoint1 + 1):n, size = 1, replace = TRUE)\n      }\n      \n      children[1,] <- parents[1,]\n      children[2,] <- parents[2,]\n      \n      \n      \n      children[1, crossOverPoint1:crossOverPoint2] <- parents[2, crossOverPoint1:crossOverPoint2]\n      children[2, crossOverPoint1:crossOverPoint2] <- parents[1, crossOverPoint1:crossOverPoint2]\n      \n      out <- list(children = children, fitness = fitnessChildren)\n      return(out)\n  \n      } else { # REGLAS DNF \n      \n        \n        parents <- object@population[parents,,drop = FALSE]\n        max <- object@max\n        n <- length(max)\n        children <- matrix(as.double(NA), nrow = 2, ncol = max[length(max)])\n        fitnessChildren <- rep(NA, 2)\n        \n        #Cambiar n - 1 por n, ya que es para comparar con java\n        rangCrossover1 <- 2:(n) # Si la longitud de esto es 1, no se puede usar sample\n        if(length(rangCrossover1) > 1){\n          crossOverPoint1 <- sample(rangCrossover1, size = 1, replace = TRUE)  \n        } else {\n          crossOverPoint1 <- rangCrossover1\n        }\n        \n        if(crossOverPoint1 == (n) )\n        { crossOverPoint2 <- n   } else {\n          rangCrossover2 <- (crossOverPoint1 + 1):n\n          if(length(rangCrossover2) > 1){\n            crossOverPoint2 <- sample(rangCrossover2, size = 1, replace = TRUE)\n          } else {\n            crossOverPoint2 <- rangCrossover2\n          }\n        }\n      \n          rango <- (max[crossOverPoint1 - 1] + 1):max[crossOverPoint2]\n        \n        \n        children[1,] <- parents[1,]\n        children[2,] <- parents[2,]\n        \n        children[1, rango] <- parents[2, rango]\n        children[2, rango] <- parents[1, rango]\n        \n        out <- list(children = children, fitness = fitnessChildren)\n        return(out)\n        \n    }\n}\n\n\n\n\n\n\n\n\n\n# SDIga Mutation operator\n\n.gaCAN_Mutation <- function(object, parent, ...)\n{\n  \n  mutar <- parent <- as.vector(object@population[parent,]) \n  mutar <-  .mutate(cromosoma = mutar, variable = ...[[1]], max_valor_variables = object@maxValuesRule, DNF_Rule = object@DNFRules )\n  \n  return(mutar)\n}\n\n\n\n\n\n\n\n# MESDIF Mutation operatos\n\n..gaMESDIF_Mutation <- function(object, parent, ...)\n{\n  \n  mutar <- parent <- as.vector(object@population[parent,]) \n  mutar <-  .mutateMESDIF(cromosoma = mutar, variable = ...[[1]], max_valor_variables = object@maxValuesRule, DNF_Rule = object@DNFRules )\n  \n  return(mutar)\n}\n\n\n\n\n\n\n\n#NMEEF-SD Mutation operator\n\n..gaNMEEF_Mutation <- function(object, parent, ...)\n{\n  \n  mutar <- parent <- as.vector(object@population[parent,]) \n  mutar <-  .mutateNMEEF(cromosoma = mutar, variable = ...[[1]], max_valor_variables = object@maxValuesRule, DNF_Rule = object@DNFRules )\n  \n  return(mutar)\n}\n\n\n\n\n\n\n\n\n#Selection Function of SDIGA\n\n.ga_SDIgaSelection <- function(object){\n  n <- object@popSize \n  object@population[(n + 1):nrow(object@population), ] <- NA\n  \n  \n  object@fitness[(n + 1):length(object@fitness)] <- NA\n  \n  list(population = object@population, fitness = object@fitness)\n  \n}\n\n\n\n\n\n\n# Binary Tournament selection operator for MESDIF\n\n.ga_MESDIFBinTournamentSelection <- function(elitePop, sizePop, nvars, FitnessElite, ObjValues){\n  newPop <- matrix(NA, nrow = sizePop, ncol = nvars)\n \n  nas <- which(is.na(elitePop[,1,drop = F]))\n  if(length(nas) > 0 )ObjValues <- ObjValues[- nas, , drop = F]\n  elitePop <- na.exclude(elitePop)\n\n  seleccion <- sample(NROW(elitePop), size = sizePop * 2, replace = TRUE)\n  Fitness <- numeric(sizePop)\n  Obj <- matrix(NA, nrow = sizePop + NROW(elitePop), ncol = 4)\n  \n  fit <- FitnessElite[seleccion] \n  sel <- matrix(seleccion, nrow = 2)\n  fit <- matrix(fit, nrow = 2)\n  \n  vencedor <- fit[1,] <= fit[2,]\n\n  num <- sum(vencedor)\n \n  if(num > 0){\n    b <- which(vencedor)\n    a <- sel[1, b]\n    newPop[b, ] <- elitePop[a, ]\n    Fitness[b] <- FitnessElite[a]\n    Obj[b, ] <- ObjValues[a, ]\n  } \n  b <- which(!vencedor)\n  a <- sel[2, b]\n  newPop[b, ] <- elitePop[a, ]\n  Fitness[b] <- FitnessElite[a]\n  Obj[b, ] <- ObjValues[a, ]\n\n  Obj[(sizePop + 1):NROW(Obj), ] <- ObjValues\n  list(population = newPop, fitness = Fitness, obj = Obj)\n  \n  \n}\n\n\n\n\n\n#\n#\n# This function execute the corresponding genetic algorithm in function of the value of 'algorithm'\n#\n#\n\n.ejecutarga <- function(algorithm, dataset, targetClass, n_vars, por_cubrir, nLabels, N_evals, tam_pob, p_cross = 0.5, p_mut, seed, Objetivos = c(.LocalSupport, .confianza, NULL, FALSE), Pesos = c(0.7,0.3,0), DNFRules = FALSE, cate, num, elitism = 5, porcCob = 0.5, strictDominance = TRUE, reInit = TRUE, minCnf = 0.6){\n  \n  ma <- dataset$conjuntos\n  \nif(DNFRules) {\n  ma <- Reduce(f = '+', x = ma, accumulate = TRUE)\n  ma <- c(0,ma)\n}\n  #Para reglas DNF, hay que utilizar como type el valor \"binary\", en vez de usar min y max, hay que usar el valor nBits, que indica la cantidad de genes que tiene cada cromosoma.\n  #Tambien hay que utilizar el valor 'max' para saber cu?ntos genes pertenecen a cada variable.\n  switch(algorithm, \n  \"SDIGA\" = { resultado <- .gaSDIGA(type = if(!DNFRules) \"real-valued\" else \"binary\", \n                  fitness = .fit13, dataset, matrix(unlist(.separar(dataset)), nrow = length(dataset[[2]]) - 1, ncol = length(dataset[[7]])), targetClass, por_cubrir, n_vars, nLabels, ma, FALSE, Objetivos, Pesos, DNFRules, Objetivos[[4]], FALSE,  cate, num,\n                  min = dataset[[4]][-length(dataset[[4]])],\n                  max = ma,\n                  nBits = ma[length(ma)],\n                  population = .generarPoblacion,\n                  selection = .ga_SDIgaSelection,\n                  crossover = .ga_dpCrossover,\n                  mutation = .gaCAN_Mutation,  \n                  popSize = tam_pob,\n                  pcrossover = 1 / tam_pob, \n                  pmutation = p_mut, # / length(ma), #Mutation probability applied at the gene\n                  elitism = 0,\n                  maxiter = N_evals,#floor( (N_evals - tam_pob) / (2 + tam_pob  * p_mut)),\n                  run = N_evals, # No queremos que se detenga la evaluacion.\n                  #  maxfitness = 1, # Si encontramos un cromosoma que tiene valor maximo, detenemos la busqueda.\n                  names = dataset[[2]][1:n_vars],\n                  keepBest = FALSE,\n                  parallel = FALSE,\n                  monitor = NULL,\n                  DNFRules = DNFRules,\n                  seed = seed) \n  }, \n  \"MESDIF\" =  { resultado <- .gaMESDIF(type = if(!DNFRules) \"real-valued\" else \"binary\", \n                                #fitness = .fit12, dataset, .separar(dataset = dataset), targetClass, por_cubrir, n_vars, nLabels, ma, FALSE, Objetivos, Pesos, DNFRules, Objetivos[[4]], FALSE,  cate, num,# Parametros de .fit12\n                                fitness = .fitnessMESDIF, dataset, matrix(unlist(.separar(dataset)), nrow = length(dataset[[2]]) - 1, ncol = length(dataset[[7]])), targetClass, por_cubrir, n_vars, nLabels, ma, FALSE, Objetivos, c(0.7, 0.3, 0), DNFRules, Objetivos[[4]], FALSE,  cate, num,\n                                min = dataset[[4]][-length(dataset[[4]])],\n                                max = ma,\n                                nBits = ma[length(ma)],\n                                population = .generarPoblacionMESDIF,\n                                selection = .ga_MESDIFBinTournamentSelection,\n                                crossover = .ga_dpCrossover,\n                                mutation = ..gaMESDIF_Mutation,  \n                                popSize = tam_pob,\n                                pcrossover = p_cross, \n                                pmutation = p_mut / length(ma),\n                                elitism = elitism,\n                                maxiter = N_evals,\n                                run = N_evals, # No queremos que se detenga la evaluacion.\n                                names = dataset[[2]][1:n_vars],\n                                keepBest = FALSE,\n                                parallel = FALSE,\n                                monitor = NULL,\n                                DNFRules = DNFRules,\n                                seed = seed) \n                return(resultado)\n  }, \n  \"NMEEFSD\" =  { resultado <- .gaNMEEF(type = if(!DNFRules) \"real-valued\" else \"binary\", \n                                      #fitness = .fit12, dataset, .separar(dataset = dataset), targetClass, por_cubrir, n_vars, nLabels, ma, FALSE, Objetivos, Pesos, DNFRules, Objetivos[[4]], FALSE,  cate, num,# Parametros de .fit12\n                                      fitness = .fitnessMESDIF, dataset, matrix(unlist(.separar(dataset)), nrow = length(dataset[[2]]) - 1, ncol = length(dataset[[7]])), targetClass, por_cubrir, n_vars, nLabels, ma, FALSE, Objetivos, c(0.7,0.3,0), DNFRules, Objetivos[[4]], FALSE,  cate, num, TRUE, \n                                      min = dataset[[4]][-length(dataset[[4]])],\n                                      max = ma,\n                                      nBits = ma[length(ma)],\n                                      population = .generarPoblacionNMEEF,\n                                      selection = .selectionNMEEF,\n                                      crossover = .ga_dpCrossover,\n                                      mutation = ..gaNMEEF_Mutation,  \n                                      popSize = tam_pob,\n                                      pcrossover = p_cross, \n                                      pmutation = p_mut,\n                                      elitism = 0,\n                                      maxiter = N_evals,\n                                      run = N_evals, \n                                      names = dataset[[2]][1:n_vars],\n                                      keepBest = FALSE,\n                                      parallel = FALSE,\n                                      monitor = NULL,\n                                      DNFRules = DNFRules,\n                                      seed = seed, \n                                      porcCob = porcCob,\n                                      StrictDominance = strictDominance,\n                                      reInitPop = reInit,\n                                      minCnf = minCnf) \n  return(resultado) #Devolver las que superen minConf\n  }\n  )\n  #Only for SDIGA\n  .getBestRule(resultado)\n}\n\n\n\n#\n# Mark examples of the dataset covered by the rule returned by genetic algorithm\n# ONLY FOR SDIGA\n#\n\n.marcar_ejemplos <- function(regla, dataset, targetClass, nVars, maxRegla, por_cubrir, nLabels, Objetivos = c(.LocalSupport, .confianza, NA, FALSE), Pesos = c(0.7,0.3,0), DNFRules = FALSE, cate, num){\n  \n  \n  #Devolver ejemplos nuevos cubiertos de la clase objetivo\n  #Cambiar por fit13\n  cover <- .fit13(regla = regla, dataset = dataset, noClass = matrix(unlist(.separar(dataset)), nrow = length(dataset[[2]]) - 1, ncol = length(dataset[[7]])), targetClass = targetClass, por_cubrir = por_cubrir, n_Vars = nVars,nLabels = nLabels, max_regla = maxRegla , marcar = TRUE, Objetivos = Objetivos, Pesos = Pesos, DNFRules = DNFRules, difuso = Objetivos[[4]], cate = cate, num = num)\n  \n  sumaNuevos <- sum(cover[[1]]) - sum(dataset[[\"covered\"]])\n  confi <- cover[[2]]\n  por_cubrir <- por_cubrir - sumaNuevos\n  \n  return( list(cubreNuevos = sumaNuevos > 0, covered = cover , porCubrir = por_cubrir, confidence = confi) )\n  \n}\n\n\n\n\n\n\n\n\n\n\n\n\n#\n# Returns de best rule of the genetic algorithm. In case of draw, returns the rule with less atributes.\n# \n# ONLY FOR SDIGA \n#\n.getBestRule <- function(resultado){\n  bestFitness <- resultado@fitnessValue\n  \n  empates <- which(resultado@fitness == bestFitness)\n  if(length(empates) > 1){\n    if(!resultado@DNFRules){\n      lista <- apply(X = resultado@population[empates, ], MARGIN = 1, FUN = function(x, max) sum(x != max), resultado@max )\n    } else{\n      \n      lista <- apply(X = resultado@population[empates, ], MARGIN = 1, FUN = function(x, max){\n        particip <- .getParticipantes(regla = x, max_regla = max, DNFRules = TRUE)\n        val <- numeric(0)\n        for(i in 2:length(max)){\n          if(particip[i-1])\n            val <- c(val, (max[i-1]+1):max[i])\n        }\n        sum(x[val] != 0)\n      } , resultado@max ) # ESTO HAY QUE CAMBIARLO !!\n      \n    }\n    orden <- order(lista[which(lista > 0)])\n    \n    return(resultado@population[ orden[1] , ])\n  } else {\n    return(resultado@population[ empates , ])\n  }\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#Return the fitness value(s) of a rule\n\n.fit13 <- function(regla, dataset, noClass, targetClass, por_cubrir, n_Vars, nLabels, max_regla, marcar = FALSE, Objetivos = c(.LocalSupport, .confianza, NULL, FALSE), Pesos = c(0.7,0.3,0), DNFRules = FALSE, difuso = FALSE ,test = FALSE, cate, num){\n\n  \n  if( ! any(is.na(regla))) { #Si la regla no tiene NA se puede evaluar\n    \n    regla <- as.integer(regla)\n    participantes <- logical(length(max_regla))\n    participantes <- .getParticipantes(regla = regla, max_regla = max_regla, DNFRules = DNFRules)\n    \n    \n    #If it's not the empty rule\n    if(any(participantes)){\n      \n      cat_particip <- which(cate & participantes)\n      num_particip <- which(num & participantes)\n      \n      max_regla_cat <- max_regla[cat_particip]\n      max_regla_num <- max_regla[num_particip]\n      \n      if(!DNFRules) { # CAN RULES\n        \n        #Split into numerical variables and categorical ones. (And participate in the rule)\n        if(length(cat_particip) > 0){\n          rule_cat <- regla[cat_particip]\n        }\n        \n        if(length(num_particip) > 0){\n          rule_num <- regla[num_particip]\n          \n          fuzzy_sets <- dataset[[\"fuzzySets\"]][1:nLabels, 1:3, num_particip, drop = F]\n          crispSets <- dataset[[\"crispSets\"]][1:nLabels, 1:2, num_particip, drop = F]\n          #  Get values for xmin, xmedio and xmax for fuzzy computation.   \n          n_matrices <- dim(fuzzy_sets)[3]  \n   \n          xmin <- fuzzy_sets[cbind(rule_num + 1, 1, seq_len(n_matrices))]\n          xmax <- fuzzy_sets[cbind(rule_num + 1, 3, seq_len(n_matrices))]\n          xmedio <- fuzzy_sets[cbind(rule_num + 1, 2, seq_len(n_matrices))]\n          \n          #Get values for xmin and xmax for crisp computation\n          n_matricesCrisp <- dim(crispSets)[3]  \n          xminC <- crispSets[cbind(rule_num + 1, 1, seq_len(n_matricesCrisp))]\n          xmaxC <- crispSets[cbind(rule_num + 1, 2, seq_len(n_matricesCrisp))]\n        }\n        \n        gr_perts <- .compara_CAN9(ejemplo = noClass, rule_cat = rule_cat, rule_num = rule_num, catParticip = cat_particip, numParticip = num_particip, xmin = xmin, xmedio = xmedio, xmax = xmax, n_matrices = n_matrices, xminCrisp = xminC, xmaxCrisp = xmaxC,  max_regla_cat)\n        \n      } else { # DNF RULES (FALTA EL TRATAMIENTO DE VARIABLES CATEGORICAS)\n        \n        \n        \n        \n        valNum <- mapply(FUN = ':', (max_regla_num + 1), (max_regla_num + nLabels), SIMPLIFY = FALSE)  \n        regla_num <- lapply(X = valNum, FUN = function(x, rule) rule[x], regla )\n        \n        if(length(num_particip) > 0){\n          \n          fuzzy_sets <- dataset[[\"fuzzySets\"]][1:nLabels, 1:3, num_particip, drop = F]\n          crispSets <- dataset[[\"crispSets\"]][1:nLabels, 1:2, num_particip, drop = F]\n          \n          #  Gets values for xmin, xmedio and xmax for fuzzy computation. \n          # The format is a matrix, which columns has at first value the number of numerical \n          # variable, and then, the values for xmin, xmedio, xmax, and only for values that participate in the rule\n          n_matrices <- dim(fuzzy_sets)[3] \n          valuesFuzzy <- .getFuzzyValues(regla_num = regla_num, fuzzy = fuzzy_sets)\n         \n          #Gets values for xmin and xmax for crisp computation\n          n_matricesCrisp <- dim(crispSets)[3]  \n          valuesCrisp <- .getFuzzyValues(regla_num = regla_num, fuzzy = crispSets, crisp = TRUE)\n        }\n        \n        #gr_perts <- lapply(X = noClass, FUN = .comparaDNF3, regla = regla, regla_num, cat_particip, num_particip,  max_regla_cat, max_regla_num, nLabels, fuzzy_sets, crispSets, valuesFuzzy, valuesCrisp)\n        gr_perts <- .comparaDNF4(ejemplo = noClass, regla = regla, regla_num, cat_particip, num_particip,  max_regla_cat, max_regla_num, nLabels, fuzzy_sets, crispSets, valuesFuzzy, valuesCrisp)\n        \n        \n        #gr_perts <- unlist(gr_perts)\n      }\n      \n      \n      values <- .get_values6(gr_perts = gr_perts, nombre_clases = dataset[[\"class_names\"]], dataset = dataset[[\"data\"]], targetClass = targetClass, examples_perClass = dataset[[\"examplesPerClass\"]],cov = dataset[[\"covered\"]], Ns = dataset[[\"Ns\"]], N_vars = n_Vars + 1, por_cubrir = por_cubrir, marcar = marcar, test = test, difuso = difuso)\n      \n      #Compute fitness\n      if(! marcar){\n      \n        fitness <- 0\n        if(is.function(Objetivos[[1]]) && Pesos[1] > 0){ \n          fitness <- fitness + (Objetivos[[1]](values) * Pesos[1])\n        }\n        if(is.function(Objetivos[[2]]) && Pesos[2] > 0){ \n          fitness <- fitness + (Objetivos[[2]](values) * Pesos[2])\n        }\n        if(is.function(Objetivos[[3]]) && Pesos[3] > 0) {\n          fitness <- fitness + (Objetivos[[3]](values) * Pesos[3])\n        }      \n        fitness <- fitness / (sum(Pesos))\n        # cat(\"Ns:\", values[[4]], \" - Local Support: \", .LocalSupport(values), \" - .confianza:\", .confianza(values), \" - Support: \", .Csupport(values),\" - .coverage:\", .coverage(values), \" - Fitness: \", fitness, file = \"\", fill = TRUE)\n        \n        fitness #Return\n      } else {\n        \n        values #Return\n      }\n      \n    } else{\n      0 #Return\n    }\n    \n  } else {\n    0 #Return\n  }\n  \n}\n\n\n.fitnessMESDIF <- function(regla, dataset, noClass, targetClass, por_cubrir, n_Vars, nLabels, max_regla, marcar = FALSE, Objetivos = c(.LocalSupport, .confianza, NULL, FALSE), Pesos = c(0.7,0.3,0), DNFRules = FALSE, difuso = FALSE ,test = FALSE, cate, num, NMEEF = FALSE){\n  \n  if( ! any(is.na(regla))) { #Si la regla no tiene NA se puede evaluar\n    \n    regla <- as.numeric(regla)\n    participantes <- logical(length(max_regla))\n    participantes <- .getParticipantes(regla = regla, max_regla = max_regla, DNFRules = DNFRules)\n    \n    \n    #If it's not the empty rule\n    if(any(participantes)){\n      \n      cat_particip <- which(cate & participantes)\n      num_particip <- which(num & participantes)\n      \n      max_regla_cat <- max_regla[cat_particip]\n      max_regla_num <- max_regla[num_particip]\n      \n      if(!DNFRules) { # CAN RULES\n        \n        #Split into numerical variables and categorical ones. (And participate in the rule)\n        \n        rule_cat <- regla[cat_particip]\n        rule_num <- regla[num_particip]\n        \n        if(length(num_particip) > 0){\n          fuzzy_sets <- dataset[[\"fuzzySets\"]][1:nLabels, 1:3, num_particip, drop = F]\n          crispSets <- dataset[[\"crispSets\"]][1:nLabels, 1:2, num_particip, drop = F]\n          #  Get values for xmin, xmedio and xmax for fuzzy computation.   \n          n_matrices <- dim(fuzzy_sets)[3]  \n          xmin <- fuzzy_sets[cbind(rule_num + 1, 1, seq_len(n_matrices))]\n          xmax <- fuzzy_sets[cbind(rule_num + 1, 3, seq_len(n_matrices))]\n          xmedio <- fuzzy_sets[cbind(rule_num + 1, 2, seq_len(n_matrices))]\n          \n          #Get values for xmin and xmax for crisp computation\n          n_matricesCrisp <- dim(crispSets)[3]  \n          xminC <- crispSets[cbind(rule_num + 1, 1, seq_len(n_matricesCrisp))]\n          xmaxC <- crispSets[cbind(rule_num + 1, 2, seq_len(n_matricesCrisp))]\n        }\n        \n        gr_perts <- .compara_CAN9(ejemplo = noClass, rule_cat = rule_cat, rule_num = rule_num, catParticip = cat_particip, numParticip = num_particip, xmin = xmin, xmedio = xmedio, xmax = xmax, n_matrices = n_matrices, xminCrisp = xminC, xmaxCrisp = xmaxC,  max_regla_cat)\n        \n      } else { # DNF RULES\n        \n        \n        \n        \n        valNum <- mapply(FUN = ':', (max_regla_num + 1), (max_regla_num + nLabels), SIMPLIFY = FALSE)  \n        regla_num <- lapply(X = valNum, FUN = function(x, rule) rule[x], regla )\n        \n        if(length(num_particip) > 0){\n          \n          fuzzy_sets <- dataset[[\"fuzzySets\"]][1:nLabels, 1:3, num_particip, drop = F]\n          crispSets <- dataset[[\"crispSets\"]][1:nLabels, 1:2, num_particip, drop = F]\n          \n          #  Gets values for xmin, xmedio and xmax for fuzzy computation. \n          # The format is a matrix, which columns has at first value the number of numerical \n          # variable, and then, the values for xmin, xmedio, xmax, and only for values that participate in the rule\n          n_matrices <- dim(fuzzy_sets)[3] \n          valuesFuzzy <- .getFuzzyValues(regla_num = regla_num, fuzzy = fuzzy_sets)\n          \n          #Gets values for xmin and xmax for crisp computation\n          n_matricesCrisp <- dim(crispSets)[3]  \n          valuesCrisp <- .getFuzzyValues(regla_num = regla_num, fuzzy = crispSets, crisp = TRUE)\n        }\n        \n        gr_perts <- .comparaDNF4(ejemplo = noClass, regla = regla, regla_num, cat_particip, num_particip,  max_regla_cat, max_regla_num, nLabels, fuzzy_sets, crispSets, valuesFuzzy, valuesCrisp)\n        \n\n      }\n      \n      \n      if(!DNFRules)\n        values <- .get_values6(gr_perts = gr_perts, nombre_clases = dataset[[\"class_names\"]], dataset = dataset[[\"data\"]], targetClass = targetClass, examples_perClass = dataset[[\"examplesPerClass\"]],cov = dataset[[\"covered\"]], Ns = dataset[[\"Ns\"]], N_vars = n_Vars + 1, por_cubrir = por_cubrir, marcar = marcar, test = test, difuso = difuso, NMEEF)\n      else\n        values <- .get_values6(gr_perts = gr_perts, nombre_clases = dataset[[\"class_names\"]], dataset = dataset[[\"data\"]], targetClass = targetClass, examples_perClass = dataset[[\"examplesPerClass\"]],cov = dataset[[\"covered\"]], Ns = dataset[[\"Ns\"]], N_vars = n_Vars + 1, por_cubrir = por_cubrir, marcar = marcar, test = test, difuso = difuso, NMEEF)\n      \n      #Compute fitness\n      if(! marcar){\n        fitness <- numeric(4)\n        fitness[1] <- if(is.function( Objetivos[[1]])) Objetivos[[1]](values) else 0\n        fitness[2] <- if(is.function( Objetivos[[2]])) Objetivos[[2]](values) else 0\n        fitness[3] <- if(is.function( Objetivos[[3]])) Objetivos[[3]](values) else 0\n        if(! NMEEF)\n          fitness #Return\n        else \n          list(fit = fitness, covered = values[[13]]) # Return\n      } else {\n        \n        values #Return\n      }\n      \n    } else{\n      c(0,0,0,0) #Return\n    }\n    \n  } else {\n    c(0,0,0,0) #Return\n  }\n  \n}\n\n\n#'\n#' Obtains the belonging degree of every example of a dataset to a given rule\n#' \n#' @param regla The rule to compare example. This rule must be in canonica vector representation. (See Rule.toRuleCANRepresentation function)\n#' @param dataset The complete keel dataset object to get the examples\n#' @param noClass a matrix with all examples without the class attribute. One examples PER COLUMN\n#' @param nLabels number of fuzzy Labels that have numerical attributes\n#' @param max_regla maximum value of all attributes ($conjuntos of the keel dataset)\n#' @param cate logical vector indicating which attributes are categorical\n#' @param num logical vector indicating which attributes are numerical\n#' @param The T-norm to use. 0 to Minimum T-norm, 1 to Product T-norm.\n#'\n#' @return a numeric vector with the belonging degree of every example to the given rule.\n#' \n.fitnessFuGePSD <- function(regla, dataset, noClass, nLabels, max_regla, cate, num, t_norm){\n  \n  \n  if( ! any(is.na(regla))) { #Si la regla no tiene NA se puede evaluar\n    \n    regla <- as.integer(regla)\n    participantes <- logical(length(max_regla))\n    participantes <- .getParticipantes(regla = regla, max_regla = max_regla, DNFRules = FALSE)\n    \n    \n    #If it's not the empty rule\n    if(any(participantes)){\n      \n      cat_particip <- which(cate & participantes)\n      num_particip <- which(num & participantes)\n      \n      max_regla_cat <- max_regla[cat_particip]\n      max_regla_num <- max_regla[num_particip]\n      \n     \n        \n        #Split into numerical variables and categorical ones. (And participate in the rule)\n        if(length(cat_particip) > 0){\n          rule_cat <- regla[cat_particip]\n        }\n        \n        if(length(num_particip) > 0){\n          rule_num <- regla[num_particip]\n          \n          fuzzy_sets <- dataset[[\"fuzzySets\"]][1:nLabels, 1:3, num_particip, drop = F]\n          crispSets <- dataset[[\"crispSets\"]][1:nLabels, 1:2, num_particip, drop = F]\n          #  Get values for xmin, xmedio and xmax for fuzzy computation.   \n          n_matrices <- dim(fuzzy_sets)[3]  \n          \n          xmin <- fuzzy_sets[cbind(rule_num + 1, 1, seq_len(n_matrices))]\n          xmax <- fuzzy_sets[cbind(rule_num + 1, 3, seq_len(n_matrices))]\n          xmedio <- fuzzy_sets[cbind(rule_num + 1, 2, seq_len(n_matrices))]\n          \n          #Get values for xmin and xmax for crisp computation\n          n_matricesCrisp <- dim(crispSets)[3]  \n          xminC <- crispSets[cbind(rule_num + 1, 1, seq_len(n_matricesCrisp))]\n          xmaxC <- crispSets[cbind(rule_num + 1, 2, seq_len(n_matricesCrisp))]\n        }\n        \n      #return\n        Rule.compatibility(ejemplo = noClass, rule_cat = rule_cat, rule_num = rule_num, catParticip = cat_particip, numParticip = num_particip, xmin = xmin, xmedio = xmedio, xmax = xmax, n_matrices = n_matrices, max_cat = max_regla_cat, max_num = max_regla_num, t_norm = t_norm)\n        \n      \n    }\n  }\n}\n#         values <- .get_values6(gr_perts = gr_perts, nombre_clases = dataset[[\"class_names\"]], dataset = dataset[[\"data\"]], targetClass = targetClass, examples_perClass = dataset[[\"examplesPerClass\"]],cov = dataset[[\"covered\"]], Ns = dataset[[\"Ns\"]], N_vars = n_Vars + 1, por_cubrir = por_cubrir, marcar = marcar, test = test, difuso = difuso)\n#       \n#       #Compute fitness\n#       if(! marcar){\n#         \n#         fitness <- 0\n#         if(is.function(Objetivos[[1]]) && Pesos[1] > 0){ \n#           fitness <- fitness + (Objetivos[[1]](values) * Pesos[1])\n#         }\n#         if(is.function(Objetivos[[2]]) && Pesos[2] > 0){ \n#           fitness <- fitness + (Objetivos[[2]](values) * Pesos[2])\n#         }\n#         if(is.function(Objetivos[[3]]) && Pesos[3] > 0) {\n#           fitness <- fitness + (Objetivos[[3]](values) * Pesos[3])\n#         }      \n#         fitness <- fitness / (sum(Pesos))\n#         # cat(\"Ns:\", values[[4]], \" - Local Support: \", .LocalSupport(values), \" - .confianza:\", .confianza(values), \" - Support: \", .Csupport(values),\" - .coverage:\", .coverage(values), \" - Fitness: \", fitness, file = \"\", fill = TRUE)\n#         \n#         fitness #Return\n#       } else {\n#         \n#         values #Return\n#       }\n#       \n#     } else{\n#       0 #Return\n#     }\n#     \n#   } else {\n#     0 #Return\n#   }\n  \n\n\n\n\n\n\n\n",
    "created" : 1444985819365.000,
    "dirty" : false,
    "encoding" : "ISO8859-1",
    "folds" : "",
    "hash" : "3814689643",
    "id" : "83F10E6D",
    "lastKnownWriteTime" : 1445005006,
    "path" : "E:/Escritorio/SDR/R/ga.R",
    "project_path" : "R/ga.R",
    "properties" : {
    },
    "relative_order" : 5,
    "source_on_save" : false,
    "type" : "r_source"
}